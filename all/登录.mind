{"root":{"data":{"id":"dbqxbdz4wio0","created":1754034440719,"text":"登录"},"children":[{"data":{"id":"dbqxbgxd0uw0","created":1754034447142,"text":"ABAC","note":"ABAC (Attribute-Based Access Control) 是一种基于属性的访问控制模型，它通过评估主体、客体、操作和环境的属性来动态决定访问权限。以下是关于 ABAC 的详细介绍：\n\n1. 核心概念\n\n• 主体 (Subject)：发起访问请求的实体，如用户、服务或应用程序，具有角色、部门、职位等属性。\n\n• 客体 (Object)：被访问的资源，如文件、数据库或API，具有类型、敏感级别等属性。\n\n• 操作 (Action)：主体对客体的行为，如“读取”“写入”等。\n\n• 环境 (Environment)：访问时的上下文条件，如时间、地点或网络状态。\n\n• 策略 (Policy)：基于属性组合的规则，用于动态授权或拒绝访问。\n\n2. 工作原理\n\n1. 属性收集：系统收集主体、客体、操作和环境的属性。\n2. 策略评估：将属性与预定义的策略匹配，判断是否满足访问条件。\n3. 决策执行：根据评估结果允许或拒绝访问。\n\n3. 优势\n\n• 灵活性：支持细粒度控制，适应复杂场景（如云计算、物联网）。\n\n• 动态性：实时调整权限，例如根据时间或位置限制访问。\n\n• 可扩展性：易于添加新属性或调整策略。\n\n4. 挑战\n\n• 复杂性：属性管理和策略维护难度较高。\n\n• 性能开销：实时属性评估可能影响系统响应速度。\n\n• 审计困难：动态决策过程难以追溯。\n\n5. 应用场景\n\n• 医疗系统：根据医生角色、患者状态和时间动态授权访问病历。\n\n• 云计算：基于用户属性（如部门）和环境（如IP地址）控制资源访问。\n\n• 跨组织协作：通过属性（如安全级别）而非固定身份管理权限。\n\n6. 与其他模型的对比\n\n• RBAC：ABAC 比基于角色的模型更灵活，但实现更复杂。\n\n• TBAC：ABAC 适用于属性驱动的动态控制，而 TBAC 聚焦任务流程中的权限变化。\n\n7. 实现标准\n\n• XACML：一种基于 XML 的策略语言，常用于 ABAC 系统。\n\n总结\n\nABAC 适用于需要高灵活性和动态权限管理的场景，但其复杂性和性能成本需权衡。在实际应用中，常与 RBAC 结合使用以平衡效率与灵活性。"},"children":[]},{"data":{"id":"dbqxbm6mnt40","created":1754034458586,"text":"RBAC","note":"RBAC（Role-Based Access Control，基于角色的访问控制）是一种通过角色分配实现权限管理的访问控制机制，其核心思想是将权限与角色关联，用户通过被赋予特定角色来获得相应的系统操作权限。以下是关于RBAC权限管理的详细解析：\n\n1. 核心要素\n\nRBAC模型包含三个基本实体和两层映射关系：  \n• 用户（User）：系统的操作主体，如员工、管理员等。  \n\n• 角色（Role）：代表一组权限的集合，通常对应组织中的岗位或职责（如“财务专员”“项目经理”）。  \n\n• 权限（Permission）：定义对资源的具体操作（如“读取文件”“删除记录”）。  \n\n• 映射关系：  \n\n  • 用户与角色关联（多对多）：一个用户可拥有多个角色，一个角色可分配给多个用户。  \n\n  • 角色与权限绑定（多对多）：角色通过权限模板预设操作范围。  \n\n2. 实现方式\n\n• 基础模型：用户→角色→权限的三层结构，权限决策仅依赖角色，而非直接识别用户身份。  \n\n• 高级扩展：  \n\n  • 角色继承：子角色可继承父角色的权限，简化权限分配（如“部门经理”自动继承“普通员工”权限）。  \n\n  • 动态调整：支持实时更新角色权限或用户角色分配，适应组织变化。  \n\n  • 细粒度控制：权限可划分为模块权限（菜单访问）、功能权限（按钮操作）和数据权限（数据范围隔离）。  \n\n3. 优势与局限性\n\n• 优势：  \n\n  • 简化管理：通过角色批量调整权限，减少逐个配置用户权限的复杂度。  \n\n  • 支持最小权限原则：限制用户仅获取必要权限，降低安全风险。  \n\n  • 易于审计：角色权限关系清晰，便于追溯和合规检查。  \n\n• 局限性：  \n\n  • 角色爆炸：大型系统中角色数量可能激增，导致管理困难。  \n\n  • 静态性：难以动态响应上下文需求（如临时权限或环境变量）。  \n\n4. 典型应用场景\n\n• 企业信息系统：如ERP、CRM中按部门/岗位分配权限（如销售员仅访问客户模块）。  \n\n• 云计算平台：Azure、AWS等通过内置角色（如“存储读取者”）管理资源访问。  \n\n• 操作系统：Windows的“Administrators”组与“Users”组权限划分。  \n\n5. 与其他模型的对比\n\n• 与ABAC的区别：RBAC基于静态角色，而ABAC基于动态属性（如时间、位置）进行更细粒度的控制。  \n\n• 与DAC/MAC的区别：RBAC比自主访问控制（DAC）更结构化，比强制访问控制（MAC）更灵活。  \n\n总结\n\nRBAC通过角色中介实现了权限管理的平衡，适合角色定义明确的组织。尽管存在灵活性不足的问题，但其简洁性和可维护性使其成为主流的权限控制模型。在实际应用中，常与ABAC结合以弥补动态控制的不足。"},"children":[]},{"data":{"id":"dbqxi7cjna80","created":1754034974841,"text":"多租户","note":"多租户（Multi-Tenancy）是一种软件架构技术，指单个软件实例或系统能够同时为多个用户或组织（称为“租户”）提供服务，且租户之间的数据和配置相互隔离。这种架构广泛应用于云计算、SaaS（软件即服务）等领域，通过资源共享降低成本，同时确保租户间的独立性和安全性。\n\n核心特点\n\n1. 资源共享  \n   多个租户共享同一套基础设施（如服务器、数据库、应用程序），提高资源利用率，降低硬件和运维成本。\n   \n2. 数据隔离  \n   每个租户的数据在逻辑或物理层面隔离，确保隐私和安全。例如：\n   • 逻辑隔离：通过租户ID、Schema或命名空间区分数据。\n\n   • 物理隔离：为高安全需求租户提供独立数据库或硬件资源。\n\n3. 可配置性  \n   租户可自定义界面、功能或权限，满足个性化需求，而无需修改核心代码。\n\n实现方式\n\n• 数据库层  \n\n  • 独立数据库：每个租户一个数据库（隔离性最高，成本高）。\n\n  • 共享数据库+独立Schema：平衡隔离性与成本。\n\n  • 共享表+租户ID字段：成本最低，但隔离性较弱。\n\n• 应用层  \n\n  • 通过中间件或代码逻辑（如租户上下文）动态路由请求。\n\n• 虚拟化技术  \n\n  使用虚拟机或容器（如Docker、Kubernetes）为租户提供独立运行环境。\n\n优势与挑战\n\n• 优势  \n\n  • 成本效益：分摊硬件和运维成本。\n\n  • 灵活扩展：动态调整资源分配，适应业务增长。\n\n  • 集中管理：简化升级和维护流程。\n\n• 挑战  \n\n  • 安全风险：需防范跨租户数据泄露。\n\n  • 性能优化：避免资源竞争导致的性能瓶颈。\n\n  • 运维复杂性：需监控多租户的故障和资源使用情况。\n\n典型应用场景\n\n1. SaaS服务：如CRM（客户关系管理）、ERP（企业资源计划）系统。\n2. 云计算平台：如AWS、阿里云的多租户资源池。\n3. 容器化平台：如Kubernetes通过命名空间实现多租户隔离。\n\n总结\n\n多租户架构通过共享与隔离的平衡，实现了高效、灵活且安全的服务交付，是现代云计算和SaaS的核心技术之一。选择具体实现方式时需权衡隔离级别、成本及业务需求。"},"children":[]},{"data":{"id":"dbqxlsxtgd40","created":1754035256932,"text":"gateway","note":"Spring Gateway（即Spring Cloud Gateway）是Spring Cloud生态系统中的核心API网关组件，其核心作用是为微服务架构提供统一的请求入口，通过路由、过滤、安全控制等机制管理和保护后端服务。以下是其主要作用及功能详解：\n\n🚪 1. 统一入口与路由转发\n\n作为所有外部请求的唯一入口，Gateway接收客户端请求，并根据预设规则（如路径、请求头、参数等）动态路由到对应的微服务。  \n• 路由规则示例：  \n  spring:\n    cloud:\n      gateway:\n        routes:\n          - id: user-service\n            uri: lb://user-service  # lb://表示负载均衡\n            predicates:             # 匹配条件\n              - Path=/user/**       # 路径匹配规则\n  \n  此配置将/user/**的请求转发到名为user-service的微服务，隐藏后端服务的真实地址，简化客户端调用。\n\n⚖️ 2. 负载均衡\n\n集成Spring Cloud LoadBalancer，自动从注册中心（如Nacos、Eureka）获取服务实例列表，并将请求均衡分发到多个实例，提升系统可用性。\n\n🔐 3. 安全与权限控制\n\n• 统一鉴权：在网关层集成Spring Security、JWT或OAuth2，实现登录验证、权限校验等逻辑，拦截非法请求，避免重复鉴权代码。  \n\n• 黑白名单/IP过滤：拦截恶意IP或限制特定来源访问。\n\n🛡️ 4. 流量治理\n\n• 限流熔断：基于令牌桶算法（如RedisRateLimiter）限制每秒请求量，或结合Resilience4j实现熔断，防止服务过载崩溃。  \n\n• 灰度发布：按比例将流量分发到新/旧服务版本，验证功能稳定性。\n\n🔧 5. 请求/响应处理\n\n• 过滤器链（Filters）：  \n\n  • 修改请求/响应：添加/删除请求头、参数（如AddRequestHeader）或重写路径（如StripPrefix）。  \n\n  • 日志与监控：记录请求日志、耗时，集成Spring Boot Actuator或Prometheus实现实时监控。  \n\n• 跨域支持（CORS）：统一配置跨域策略，解决前端跨域问题。\n\n🔄 6. 协议转换与高级路由\n\n• 协议转换：支持HTTP/HTTPS、WebSocket等协议互转，例如将HTTP请求转发到WebSocket服务。  \n\n• 响应聚合：合并多个微服务的响应结果，减少客户端请求次数。\n\n💎 总结\n\nSpring Gateway的核心价值在于：  \n通过统一入口、动态路由、负载均衡、安全防护、流量控制、请求加工等能力，简化微服务架构的复杂度，提升系统的可维护性、安全性与高可用性。 其基于Netty和WebFlux的异步非阻塞模型，性能远超传统网关（如Zuul 1.x），是Spring Cloud微服务架构的\"流量守门人\"。","layout_mind_offset":{"x":-7.999999761581535,"y":11.999999642372018},"expandState":"expand"},"children":[{"data":{"id":"dbqxnw68u600","created":1754035420701,"text":"路由","layout_left_offset":{"x":-59.99999821186054,"y":11.999999642372131},"note":"在 Spring Cloud Gateway 中，“路由”（Route）是一个核心概念，它定义了如何将外部请求匹配并转发到后端微服务。路由的本质是建立一套规则系统，决定请求的入口路径、过滤逻辑以及最终转发的目标。其核心组成和工作流程如下：\n\n🧩 一、路由的核心组成\n\n一个路由由四个关键要素构成：\n1. ID（唯一标识）  \n   用于唯一标识路由规则，便于管理和调试。  \n   示例：id: user-service-route。\n\n2. URI（目标服务地址）  \n   定义请求转发的目的地，支持两种形式：  \n   • 静态地址：如 http://localhost:8080  \n\n   • 动态服务发现：如 lb://user-service（lb表示负载均衡，自动从注册中心获取实例）。\n\n3. Predicates（断言集合）  \n   匹配请求的条件列表，所有条件均满足时路由才生效。常用断言类型包括：  \n\n    断言类型 作用 配置示例\nPath 匹配请求路径 - Path=/api/users/**\nMethod 匹配HTTP方法（GET/POST等） - Method=GET,POST\nHeader 匹配请求头 - Header=X-Request-Id, \\d+\nQuery 匹配URL参数 - Query=name,tom\nCookie 匹配Cookie值 - Cookie=sessionId, abc.*\nHost 匹配域名 - Host=**.example.com\nAfter/Before 按时间区间匹配 - After=2025-01-01T00:00:00+08:00\nWeight 按权重分流（灰度发布）\n - Weight=group-a, 80                     。\n\n4. Filters（过滤器链）  \n   在请求转发前后执行逻辑处理，分为局部过滤器（作用于单一路由）和全局过滤器（作用于所有路由）：  \n   • 常用局部过滤器：  \n\n     ◦ StripPrefix：移除路径前缀（如 /api/user → /user）  \n\n     ◦ RewritePath：重写请求路径（如 /v1/user → /user）  \n\n     ◦ AddRequestHeader：添加请求头  \n\n     ◦ RateLimit：限流（基于令牌桶算法）  \n\n     ◦ Retry：失败重试  \n\n   • 全局过滤器示例：  \n\n     ◦ 黑名单拦截（BlackListFilter）  \n\n     ◦ 跨域处理（CorsWebFilter）。\n\n⚙️ 二、路由的工作流程\n\n当请求到达网关时，路由的匹配与处理流程如下：  \n1. 断言匹配（Predicate Matching）  \n   RoutePredicateHandlerMapping 遍历所有路由，检查请求是否符合某个路由的断言条件。一旦匹配成功，立即停止后续路由的匹配（类似责任链模式）。  \n   • 注意：路由的默认匹配顺序按配置顺序执行，可通过 order 属性调整优先级（值越小优先级越高）。\n\n2. 过滤器链执行（Filter Chain）  \n   匹配成功后，请求进入 FilteringWebHandler，依次执行以下逻辑：  \n   • Pre-Filters：转发前修改请求（如添加头信息、鉴权）  \n\n   • 目标服务调用：将请求转发至 URI 指定的服务  \n\n   • Post-Filters：收到响应后修改结果（如添加响应头、日志记录）。\n\n3. 负载均衡与转发  \n   若 URI 使用 lb://service-name 格式，网关会通过 LoadBalancerClientFilter 从注册中心（如 Nacos）获取服务实例列表，并按策略（如轮询）分发请求。\n\n🌐 三、路由的典型应用场景\n\n1. *  \n   结合服务注册中心（如 Nacos），自动发现微服务实例，无需硬编码目标地址。  \n   配置示例：  \n   spring:\n     cloud:\n       gateway:\n         discovery:\n           locator:\n             enabled: true  # 开启动态路由\n   \n\n2. 灰度发布与流量控制  \n   使用 Weight 断言按比例分流请求到新旧版本服务，或通过 RateLimit 过滤器限制并发请求量。\n\n3. 统一安全与协议转换  \n   • 安全：在网关层统一实现 JWT 鉴权、IP 黑名单拦截  \n\n   • 协议转换：将 HTTP 请求转发到 WebSocket 服务。\n\n💎 总结\n\n在 Spring Cloud Gateway 中，路由（Route）是连接客户端与微服务的规则引擎：  \n它通过 断言（Predicates）匹配请求 → 过滤器（Filters）加工请求/响应 → URI 定位目标服务，最终实现请求的精准转发、负载均衡和安全管控。  \n\n路由的本质是解耦客户端与后端服务，使微服务架构具备动态扩展、灵活调度和安全隔离的能力。"},"children":[]},{"data":{"id":"dbu3p5y4smo0","created":1754357126871,"text":"过滤器","note":"## 一 解释一\n通过网关路由的请求是指那些被Spring Cloud Gateway转发到下游微服务的请求，而不是直接处理的请求。\n\n具体解释：\n\n1. **通过网关路由的请求**：\n   - 客户端请求网关上的某个路径（如 `/api/user-service/**`）\n   - 网关根据路由配置将请求转发到对应的后端微服务\n   - 这类请求会经过GlobalFilter处理\n\n2. **直接处理的请求**：\n   - 客户端直接请求网关应用自身定义的端点（如 `/redirect`）\n   - 请求由网关应用内部的Controller直接处理\n   - 这类请求不会经过GlobalFilter，但会经过WebFilter\n\n在你的案例中，`/redirect`端点是直接由网关应用的RedirectController处理的，而不是路由到其他微服务，所以GlobalFilter不会捕获到这个请求。\n\n如果你希望过滤所有进入网关的请求（包括直接处理的和路由转发的），应该使用WebFilter而不是GlobalFilter。\n## 二 解释二\n既然你已经确认过滤器是GlobalFilter类型、有@Component注解并且Order设置合理，但仍然无法捕获到请求，可能的原因有以下几种：\n\n1. **请求根本没有到达网关**：你的RedirectController可能是一个直接的Spring Boot MVC控制器，而不是通过网关路由的微服务。在Spring Cloud Gateway中，GlobalFilter只对通过网关路由的请求生效。\n\n2. **组件扫描问题**：确保LoggingGlobalFilter类在正确的包路径下，并且该包被Spring Boot的组件扫描覆盖。\n\n3. **应用类型混淆**：确认你的应用确实是作为Spring Cloud Gateway运行，而不是普通的Spring Boot Web应用。\n\n让我们检查一下你的应用是否正确配置为网关应用：\n\n1. 确保你的主应用类上有`@EnableDiscoveryClient`或相关注解\n2. 确保pom.xml中有spring-cloud-starter-gateway依赖\n3. 确保application.yml中有相关路由配置\n\n如果你的RedirectController是网关应用中的一个端点，而不是后端服务，那么GlobalFilter可能不会捕获它，因为GlobalFilter主要用于过滤通过网关路由到下游服务的请求。\n\n如果你想要过滤所有进入网关的请求（包括直接访问网关的端点），你需要使用WebFilter而不是GlobalFilter：\n\n```java\npackage com.dfsoft.eagle3.gateway.filter;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport org.springframework.web.server.WebFilter;\nimport org.springframework.web.server.WebFilterChain;\nimport reactor.core.publisher.Mono;\n\n@Component\npublic class LoggingGlobalFilter implements WebFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {\n\n        ServerHttpRequest request = exchange.getRequest();\n        System.out.println(\"Request path: \" + request.getPath());\n        System.out.println(\"Request method: \" + request.getMethod());\n\n        return chain.filter(exchange).then(Mono.fromRunnable(() -> {\n            // 这里可以添加对响应的一些处理\n            System.out.println(\"Response status: \" + exchange.getResponse().getStatusCode());\n        }));\n    }\n\n    @Override\n    public int getOrder() {\n        // 定义过滤器的顺序，值越小优先级越高\n        return -100;\n    }\n}\n```\n\n\nWebFilter会捕获所有进入应用的HTTP请求，而GlobalFilter只捕获通过网关路由的请求。如果你要捕获所有请求（包括直接访问网关的端点），应该使用WebFilter。"},"children":[]}]},{"data":{"id":"dbqxlwiyjk80","created":1754035264741,"text":"sa-token"},"children":[]},{"data":{"id":"dbqya54k1u00","created":1754037164201,"text":"session"},"children":[]},{"data":{"id":"dbqyad97r080","created":1754037181897,"text":"token"},"children":[]},{"data":{"id":"dbqyajae6vc0","created":1754037195029,"text":"cookie"},"children":[]},{"data":{"id":"dbqzoixdcbk0","created":1754041112450,"text":"技术"},"children":[{"data":{"id":"dbqzomzejns0","created":1754041121280,"text":"jwt"},"children":[]},{"data":{"id":"dbqzoqxdkmw0","created":1754041129864,"text":" "},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}